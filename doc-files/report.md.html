<meta charset="utf-8"><!-- -*- markdown -*- -->     
   
        **Procedurally Generated, Low-Poly Planet**
        **John Freeman (jcf1@williams.edu), Jose Rivas (jdr3@williams.edu),** 
        **Julia Goldman (jdg2@williams.edu),**
        **and Matheus de Carvalho Souza (mc13@williams.edu)** 


    ![A unique low-poly planet.](quality1.jpg border=1)

Introduction
============================================================================================

Despite their lack of realism, low-poly planets, such as the one above, have the ability to be aesthetically beautiful and awe-inspiring. There are a plethora of different styles that these planets can take, but for this project, we endeavored to create a low-poly planet generator that can procedurally generate cartoon-like planets reminiscent of those from Super Mario Galaxy. The cartoon-like feel of these planets allowed us to generate planets that do not have to conform to "real-world" physics, but still have an aesthetically pleasing feel to them.

Specification
============================================================================================

1. Generate a procedurally generated, tesselated planet by implementing the following:
	1. Generate a low-poly planet with the following heightfields:
		1. Sea
		2. Low-Level Terrain
		3. Mountains
	2. Use a noise function to generate these heightfields based on the planet's radius
	3. Use an edge-collapse algorithm to reduce the number of triangles
	4. Bevel the edges of the heightfields' triangles for smoother transitions
	5. Get all parameters based on constants from a file.
	5. Add low-poly objects on the planet:
		1. Fir Trees
		2. Birds
        3. Clouds
	6. Make the planet rotate on its axis
	7. Make the clouds and birds move along predetermined paths 
	8. Use a gradient background for better aesthetic.
    9. Map textures onto the planet.

2. Provide the capability to change the planet's following paramenters:
	1. Water heightfield's minimum and maximum height
	2. Low-level terrain heightfield's maximum height
	3. Mountain heightfield's maximum height
    4. Noise Functions seeds
    5. Lambertian and Glossy Color
    6. Number of Edges to Collapse
		
3. Save the following images to prove correctness:
	1. Show individual low-poly terrain mesh using a simple noise algorithm to bump the vertices.
    3. Show example of beveling.
    4. Show example of edge collapsing
    5. Show individual heightfields and full planet at varying recursion depths

4. Quality Results:
	1. A scene of a planet with some models and an interesting background
	2. A scene of a planet with a moon rotating around it
	3. A unique scene emphasizing our planets' beauty
  
5. Stretch Goals
	1. Add detailed buildings to the planets
	2. Have one planet revolve around another like a moon
  
Topic Overview
=====================================================================================

Heightfields
-----------------------------------------------------------
The planets are represented through a combination of layered, spherical heightfields. From top to bottom, these spheres represent the mountains, land, and water planes of our planet. Each has a unique noise algorithm, which creates the variation in their heights. 

Noise
-----------------------------------------------------------
Perling noise is used to generate the heights at varying locations of our three heightfields. Each field has its own unique noise functions, which rely on each other, in order to make sure the three do not interfere with one another.

Meshes
----------------------------------------------------------
The heightfields are stored as meshes. The low-polyness of the planet comes from the heightfield's mesh structure. A decimation algorithm is used to simplify the mesh. Then Beveling adds rectangles between mesh triangles to smooth out corners.

Decimation Algorithms
----------------------------------------------------------
Decimation algorithms are used, among other things, to simplify meshes by reducing the number of faces while still keeping its underlying shape and topology. 

The decimation algorithm we chose is edge collapsing, which consists of taking the $n$ least important edges away from the mesh, which takes away its adjacent faces. For our purposes we chose the least important edge to be the edge whose anlge between its adjacent face normals is closest to 180 degrees, weighted by the edge length.

An edge collapsed sphere: 
![4000 edges collapsed with angle weight, but no random start point](2016-12-02_002_starter_r2639_g3d_r981__4000_-_edges_collapsed.jpg width=300px)![Same sphere as previous picture](2016-12-02_003_starter_r2639_g3d_r981__4000_edges_collapsed.jpg width=300px)![4000 edges collapsed with no angle weight, but with random start point](2016-12-03_000_starter_r2642_g3d_r981__4000_edges_collapsed.jpg width=300px)

Bevelling
-----------------------------------------------------------
In order to create a smooth transition between triangles, we used a bevelling function. This functions shrinks each triangle face by a specified amount, causing each face to become disconnected from one another. It then fills in the missing spaces with rectangles, reconnecting the triangles together. 

![A planet with shrunken faces](beveling1.jpg width=300px)![A beveled surface](beveling.jpg width=300px)![Close-up shot](bevelingclose.jpg width=300px)

The result is a more cartoon-like feel for the planet, because it gets rid of extremely sharp edges.

Design
=====================================================================================

The following is a description of our design.

Flowchart
-------------------------------------------------------------------------------------

APP::makePlanetGUI()
       Get Constants Button
                App::unpackagePlanetSpecs()
       Save Constants Button
                App::packagePlanetSpecs
       Generate Button
                SolarSystem::containsPlanet()
                App::packagePlanetSpecs()
                Planet::generatePlanet()
                    Planet::writeSphere()
                        Planet::makeIcohedron()
                        Planet::subdivideIcohedron()
                    Mesh::collapseEdges()
                        Mesh::computeAdjacency()
                        Mesh::computeFaceNormals
                        Mesh::isCollapsable()
                            isManifoldPreserved()
                            normalsFlipped()
                                computeCurNormal()
                                computeNewNormal()
                                isSignOpposite()
                        isMoreCollapsable()
                            cosAnge()
                            squaredEdgeLength()
                        collapseOneEdge()
                            remapIndices()
                            removeDegenerateFaces()
                                isDegenerate()
                    Mesh::bevelEdges()
                        Mesh::computeAdjacency()
                        Mesh::computeNormals()
                    Mesh::toObj()
                        Mesh::computeAdjacency()
                        Mesh::computeNormals()
                    NoiseGen::generateLandImage()
                    NoiseGen::generateWaterImage()
                    NoiseGen::generateMountainImage()
                    NoiseGen::landMapImage()
                    Planet::findTreePositions()
                SolarSystem::addPlanet()
                    Planet::getPlanetOrbit()
                    SolarSystem::addPlanetToScene()
                        Planet::createWaterAnyFile()
                        Planet::createLandAnyFile()
                        Planet::createMountainAnyFile()
                        Planet::addCloudToPlanet()
                        Planet::getTreePositions()
                        SolarSystem::MakeSceneTable()
                SolarSystem::printSolarSystemToScene()
                

GAPP::makePlanetGUI() -> Generate Button -> Planet::writeSphere() -> Planet::makeIcohedron() -> Planet::subDivideIcohedron() -> GAPP::makePlanetGUI() 
-> Planet::generateNoise() -> GAPP::makePlanetGUI() -> GAPP::addPlanetToScene()

// For edge collapsing
Edge collapsing calls many static functions defined in Mesh.cpp that are not Member functions of the Mesh class. All of that is outlined in the journal. These are the functions bellow that don't have the Mesh:: prefix. If we only want member functions in the flowchart then we ought to delete them.
Mesh::collapseEdges() -> Mesh::computeAdjacency() -> Mesh::computeFaceNormals -> Mesh::isCollapsable() (calls isManifoldPreserved(), normalsFlipped() (calls computeCurNormal(), computeNewNormal(), and isSignOpposite()) -> isMoreCollapsable() (calls cosAnge() and squaredEdgeLength()) -> collapseOneEdge() (Calls remapIndices(), removeDegenerateFaces() (calls isDegenerate())

Class Descriptions
-----------------------------------------------------------------------------------------------------------------------------

|[Angled Vertex](class_angled_vertex.html): | |
|------------|---|
|[operator<](class_angled_vertex.html#af8dea9a741ccba035b79f5015adc7572) | Used for sorting vertices by angle |
|[operator>](class_angled_vertex.html#ae6d68c335a0bf593ac5b9d9e85c1407a) | Used for sorting vertices by angle |

|[App](class_app.html): | |
|------------|---|
|[addPlanetToScene](class_app.html#aa16db878375c7fa7a16108e7b9edb898) | Adds an articulated model of a mesh to the current scene |
|[makePlanetGUI](class_app.html#a9bc72b237ac25e5c1e793c9104221320) | Provides the ability to generate a planet on command |



|[Mesh](class_mesh.html): | |
|------------|---|
|[bevelEdges](class_mesh.html#adc7558052d2c7fb4ee0697805ef7cd72) | Creates new vertex and index arrays in which the original triangles are separated and shrunk andvthe gaps between them are filled in with more triangles |
|[collapseEdges](class_mesh.html#a015dfb6334430099b0061bbdc24a7289) | As outlined by Stanford Graphics http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/08_Simplification.pdf Calls computeAdjacency(), computeFaceNormals(), and isCollapsable() for each i in numEdges collapsing as many edges as possible from 0 to numEdges. |
|[computeAdjacency](class_mesh.html#a8b7b39f416aee6d204de79cb65226d05) | Fills buffers with information about the mesh's topology |
|[computeFaceNormals](class_mesh.html#ad2d3073f94942602441016a2ae5c7191) | Calculates normals for each face |
|[computeNormals](class_mesh.html#a80fe9c1e1a35dc5aa5cd088dbe0d08d6) | vertexNormalArray and faceNormalArray filled with appropriate normal values |
|[toArticulatedModel](class_mesh.html#aa25e2fa35851d7660871190eaeab737b) | Returns an articulated model of the mesh |
|[toObj](class_mesh.html#aa6aa873a3f810e2c0bfdb9e08aaf3908) | Writes an object file of the mesh |
|[create](class_mesh.html#acf65d30a393e0e492fa08878472b4847) | Returns a shared pointer to a mesh |
|[isCollapsable](class_mesh.html#a927969b67bb759490deab1acd701354f) | Called by collapseEdges(). Checks if an edge can be safely collapsed. True if not a boundary edge, if collapsing it preserves the manifold and doesn't flip adjacent face normals. |

|[NoiseGen](class_noise_gen.html): | |
|------------|---|
|[generateMountainImage](<Doxygen Link Goes Here>) | Generates noise bump map for mountains |
|[generateLandImage](<Doxygen Link Goes Here>) | Generates noise bump map for land |
|[generateSeaImage](<Doxygen Link Goes Here>) | Generates noise bump map for ocean |
|[colorMountainImage](<Doxygen Link Goes Here>) | <INSERT DESCRIPTION HERE> |
|[landMapImage](<Doxygen Link Goes Here>) | <INSERT DESCRIPTION HERE> |

|[Planet](class_planet.html): | |
|------------|---|
|[applyNoiseLand](class_planet.html#acef025087d323d0d14c68ed8e808f784) | Generates and maps noise for land |
|[applyNoiseMountain](class_planet.html#a61f483ef01185744916f3d5c880a6737) | Generates and maps noise for mountains |
|[applyNoiseWater](class_planet.html#aae1f673f08375154a869ca9df9547718) | Generates and maps noise for ocean |
|[writeSphere](class_planet.html#a4e6161f7106c7800e162213210cc23bb) | Constructs a sphere of a given recursion depth |
|[getMiddle](class_planet.html#a9264b1a5ed9484f6de3a802b674ccd3e) | Finds the middle between two points |
|[makeIcohedron](class_planet.html#a73f0047f85c0d7138283e9006cc5b729) | Makes an icohedron |
|[subdivideIcoHedron](class_planet.html#a8da7fb007fbfb344c150382ab774629a) | Divides the faces of the icohedron |

|[SolarSystem](class_solar_system.html): | |
|------------|---|
|[initializeEntityTable](<DOXYGEN LINK GOES HERE>) | Sets up and writes the entity portion of the scene |
|[initializeModelsTable](<DOXYGEN LINK GOES HERE>) | Sets up and writes the models portion of the scene |
|[initializeSceneTable](<DOXYGEN LINK GOES HERE>) | Sets up and writes the scene's lightning environment |
|[makeSceneTable](<DOXYGEN LINK GOES HERE>) | Adds entities and models initialized by their own methods to the scene |
|[printSolarSystemToScene](<DOXYGEN LINK GOES HERE>) | Outputs the Solar system to a scene file |
|[addPlanet](<DOXYGEN LINK GOES HERE>) | Adds planet to scene |
|[containsPlanet](<DOXYGEN LINK GOES HERE>) | Returns true if input planet is in the solar system |
|[removePlanet](<DOXYGEN LINK GOES HERE>) | Removes planet from scene |
|[onInit](<DOXYGEN LINK GOES HERE>) | Initializes member variables and invokes intialize methods |


Justification
------------------------------------------------------------------------------------------------------------------------------

Our planet class is used for creating spherical heightfield using noise, which are then modified and outputted from inside our mesh class. Our planet heightfield is built by applying noise to a sphere. We build our own sphere from an icohedron so we can make it as low or high poly as we desire.

[Planet](class_planet.html) is responsible for building the actual layout of the planet and uses our Mesh class to create its 3D mesh.

[NoiseGen](class_noise_gen.html) generates noise bump maps for the mountain, land and ocean planet heightfields through separate methods.

[Mesh](class_mesh.html) defines methods to compute adjacency and normal information of the input Mesh, and methods to edit the Mesh. It is used by Planet, which passes in the vertex array and the tri array of faces of the original heightfields into Mesh. Planet then invokes the methods defined in Mesh to collapse mesh edges, to bevel the mesh, and to output it to [G3D::ArticulatedModel](http://g3d.cs.williams.edu/g3d/G3D10/build/manual/class_g3_d_1_1_articulated_model.html) or to OBJ files to be used in our scenes. Collapsing edges simplifies the mesh and makes the faces look less uniform which makes the low polyness more interesting. Bevelling smoothes the edges between faces and gives more of a polygon effect to the mesh. This design choice abstracts mesh editting from mesh creation and allowed us to to work on introducing low polyness separately from generating nice planets.
    
[SolarSystem](class_solar_system.html) abstracts generating the Scene.Any file that includes our planet meshes. It defines separate methods to set up the lighting environment, write entities, write models, add and remove planet meshes from the scene. Defining this class was fundamental in cleaning up our code, since before SolarSystem we generated our whole Scene.Any in App. This abstraction allowed us to more easily and intuitively add features and polish our results. 

Results
=====================================================================================

Correctness Results
---------------------------------------------------------------------------------------

![](landDepth3.jpg width=200px) ![](landDepth5.jpg width=200px) ![](landDepth7.jpg width=200px)
![](mountainDepth3.jpg width=200px) ![](mountainDepth5.jpg width=200px) ![](mountainDepth7.jpg width=200px)
![](depth3.jpg width=200px) ![](depth5.jpg width=200px) ![](depth7.jpg width=200px)


Quality Results
--------------------------------------------------------------------------------------
Here, we show high quality images that show both the advantages and limitations of our project.  

![](low-poly.jpg)
![](quality2.jpg)
![](1.jpg)


Evocative Results
-------------------------------------------------------------------------------------
Here, we demonstrate how our planets could be used to create with various models to create interesting scenes and beautiful images. 
    
![](video.mp4)

![](qualityTex.jpg)
![](qualityTex2.jpg)
![](lava.jpg)
![](lava2.jpg)
Schedule
===================================================================

|To Do| Date | Person|
|-----|------|-------|
|Sphere Creation Draft| 13 Nov. 2016 | John and Jose|
|Mesh Class Draft| 13 Nov. 2016 | Julia and Matheus|
|Report Draft | 14 Nov. 2016 | John and Jose|
|Sphere Creation MVP| 17 Nov. 2016 | John and Jose|
|Mesh Class MVP| 17 Nov. 2016 | Julia and Matheus|
|Report MVP | 1 Dec. 2016 | All|
|Sphere Creation Polish| 7 Dec. 2016 | John and Jose|
|Mesh Class Polish| 7 Dec. 2016 | Julia and Matheus|
|Report Polish | 7 Dec. 2016 | All|

Change Log
===================================================================
1. Created initial plans. All 11/10/16.
2. Created a seperate mesh class. Julia and Matheus 11/12/16.
3. Created a sperate class for our sphere generator. John and Jose 11/13/16.
4. Sphere generator renamed to Planet. John and Jose 11/14/16
5. Created a noise class to create images with noise. Jose 11/16/16
6. Added GUI to APP. Julia 11/17/16
7. Moved noise class functions to planet class. Not using NoiseGen anymore. John 11/18/16
8. Added solar system class to control Scene file. Jose 12/4

Acknowledgements and Bibliography
============================================

<b>Icosphere Information:</b>

[#Larsen]: Larsen, Ken.  "Subdivision of Icosahedrons". CoreDumping, 15 April 2012. Web. 13, Nov. 2016. http://blog.coredumping.com/subdivision-of-icosahedrons/

<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>

<script src="../common.js"></script>