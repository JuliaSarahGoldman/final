<meta charset="utf-8"><!-- -*- markdown -*- -->     
   
        **Procedurally Generated, Low-Poly Planets**
        **John Freeman (jcf1@williams.edu), Jose Rivas (jdr3@williams.edu),** 
        **Julia Goldman (jdg2@williams.edu),**
        **and Matheus de Carvalho Souza (mc13@williams.edu)** 


    ![A unique, procedually generated low-poly planet.](quality1.jpg border=1)

Introduction
============================================================================================

Despite their lack of realism, low-poly planets, such as the one above, have the ability to be aesthetically beautiful and awe-inspiring. There are a plethora of different styles that these planets can take, but for this project, we endeavored to create a low-poly planet generator that can procedurally generate cartoon-like planets reminiscent of those from Super Mario Galaxy. The cartoon-like feel of these planets allowed us to generate planets that do not have to conform to "real-world" physics, but still have an aesthetically pleasing feel to them.

Specification
============================================================================================

1. Generate a procedurally generated, tesselated planet by implementing the following:
	1. Generate a low-poly planet with the following heightfields:
		1. Sea
		2. Low-Level Terrain
		3. Mountains
	2. Use a noise function to generate these heightfields based on the planet's radius
	3. Use an edge-collapse algorithm to reduce the number of triangles
	4. Bevel the edges of the heightfields' triangles for smoother transitions
	5. Get all parameters based on constants from a file.
	5. Add low-poly objects on the planet:
		1. Fir Trees
		2. Birds
        3. Clouds
	6. Make the planet rotate on its axis
	7. Make the clouds and birds move along predetermined paths 
	8. Use a gradient background for better aesthetic.
    9. Map textures onto the planet.

2. Provide the capability to change the planet's following paramenters:
	1. Water heightfield's minimum and maximum height
	2. Low-level terrain heightfield's maximum height
	3. Mountain heightfield's maximum height
    4. Noise Functions seeds
    5. Lambertian and Glossy Color
    6. Number of Edges to Collapse
		
3. Save the following images to prove correctness:
	1. Show individual low-poly terrain mesh using a simple noise algorithm to bump the vertices.
    3. Show example of beveling.
    4. Show example of edge collapsing
    5. Show individual heightfields and full planet at varying recursion depths

4. Quality Results:
	1. A scene of a planet with some models and an interesting background
	2. A scene of a planet with a moon rotating around it
	3. A unique scene emphasizing our planets' beauty
  
5. Stretch Goals
	1. Add detailed buildings to the planets
	2. Have one planet revolve around another like a moon
  
Topic Overview
=====================================================================================

Heightfields
-----------------------------------------------------------
The planets are represented through a combination of layered, spherical heightfields. From top to bottom, these spheres represent the mountains, land, and water planes of our planet. Each has a unique noise algorithm, which creates the variation in their heights. 

Noise
-----------------------------------------------------------
Perling noise is used to generate the heights at varying locations of our three heightfields. Each field has its own unique noise functions, which rely on each other, in order to make sure the three do not interfere with one another.

![Example of noise used for planet land](noiseExampleLand.png width=200px) ![Example of noise used for planet mountains](noiseExampleMount.png width=200px)

Meshes
----------------------------------------------------------
The heightfields are stored as meshes. The low-polyness of the planet comes from the heightfield's mesh structure. Because we make our own icosphere, we can control the number of polygons our inintial sphere has. A decimation algorithm is used to simplify the mesh. Then Beveling adds rectangles between mesh triangles to smooth out corners.

Decimation Algorithms
----------------------------------------------------------
Decimation algorithms are used to simplify meshes by reducing the number of faces while still keeping its underlying shape and topology. 

The decimation algorithm we chose is edge collapsing as outlined by [#Stanford_Graphics] and [#Shertler], which consists of taking the $n$ least important edges away from the mesh, which effectifely removes its adjacent faces. For our purposes we chose the least important edge to be the edge whose angle between its adjacent face normals is closest to 180 degrees, weighted by the edge length.

The main purpose of edge collapsing in our project, however, was not to merely simplify the mesh, but to make the low polyness aesthetic of our planets more evident by making the polygon subdivision less uniform. 

An edge collapsed sphere: 
![4000 edges collapsed with angle weight, but no random start point](2016-12-02_002_starter_r2639_g3d_r981__4000_-_edges_collapsed.jpg width=300px)![Same sphere as previous picture](2016-12-02_003_starter_r2639_g3d_r981__4000_edges_collapsed.jpg width=300px)![4000 edges collapsed with no angle weight, but with random start point](2016-12-03_000_starter_r2642_g3d_r981__4000_edges_collapsed.jpg width=300px)

Bevelling
-----------------------------------------------------------
In order to create a smooth transition between triangles, we used a bevelling function. This functions shrinks each triangle face by a specified amount, moving the vertices of each triangles towards the triangle's center, causing each face to become disconnected from one another. It then fills in the missing spaces with rectangles, reconnecting the triangles to keep the mesh air tight. 

![A planet with shrunken faces](beveling1.jpg width=300px)![A beveled surface](beveling.jpg width=300px)![Close-up shot](bevelingclose.jpg width=300px)

The result is a more cartoon-like feel for the planet, because it gets rid of extremely sharp edges.

Design
=====================================================================================

The following is a description of our design.

Flowchart
-------------------------------------------------------------------------------------

1. APP::makePlanetGUI()
       1. Get Constants Button
                1. App::unpackagePlanetSpecs()
       2. Save Constants Button
                1. App::packagePlanetSpecs
       3. Generate Button
                1. SolarSystem::containsPlanet()
                2. App::packagePlanetSpecs()
                3. Planet::generatePlanet()
                    1. Planet::writeSphere()
                        1. Planet::makeIcohedron()
                        2. Planet::subdivideIcohedron()
                    2. NoiseGen::generateLandImage()
                    3. NoiseGen::generateWaterImage()
                    4. NoiseGen::generateMountainImage()
                    5. Mesh::collapseEdges()
                        1. Mesh::computeAdjacency()
                        2. Mesh::computeFaceNormals
                        3.  Mesh::isCollapsable()
                            1. isManifoldPreserved()
                            2. normalsFlipped()
                                1. computeCurNormal()
                                2. computeNewNormal()
                                3. isSignOpposite()
                        4. isMoreCollapsable()
                            1. cosAnge()
                            2. squaredEdgeLength()
                        5. collapseOneEdge()
                            1. remapIndices()
                            2. removeDegenerateFaces()
                                1. isDegenerate()
                    6. Mesh::bevelEdges()
                        1. Mesh::computeAdjacency()
                        2. Mesh::computeNormals()
                    7. Mesh::toObj()
                        1. Mesh::computeAdjacency()
                        2. Mesh::computeNormals()
                    8. NoiseGen::landMapImage()
                    9. Planet::findTreePositions()
                4. SolarSystem::addPlanet()
                    1. Planet::getPlanetOrbit()
                    2. SolarSystem::addPlanetToScene()
                        1. Planet::createWaterAnyFile()
                        2. Planet::createLandAnyFile()
                        3. Planet::createMountainAnyFile()
                        4. Planet::addCloudToPlanet()
                        5. Planet::getTreePositions()
                        6. SolarSystem::MakeSceneTable()
                5. SolarSystem::printSolarSystemToScene()


Class Descriptions
-----------------------------------------------------------------------------------------------------------------------------

|[Angled Vertex](class_angled_vertex.html): | |
|------------|---|
|[operator<](class_angled_vertex.html#af8dea9a741ccba035b79f5015adc7572) | Used for sorting vertices by angle |
|[operator>](class_angled_vertex.html#ae6d68c335a0bf593ac5b9d9e85c1407a) | Used for sorting vertices by angle |

|[App](class_app.html): | |
|------------|---|
|[addPlanetToScene](class_app.html#aa16db878375c7fa7a16108e7b9edb898) | Adds an articulated model of a mesh to the current scene |
|[makePlanetGUI](class_app.html#a9bc72b237ac25e5c1e793c9104221320) | Provides the ability to generate a planet on command |



|[Mesh](class_mesh.html): | |
|------------|---|
|[bevelEdges](class_mesh.html#adc7558052d2c7fb4ee0697805ef7cd72) | Creates new vertex and index arrays in which the original triangles are separated and shrunk andvthe gaps between them are filled in with more triangles |
|[collapseEdges](class_mesh.html#a015dfb6334430099b0061bbdc24a7289) | As outlined by Stanford Graphics http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/08_Simplification.pdf Calls computeAdjacency(), computeFaceNormals(), and isCollapsable() for each i in numEdges collapsing as many edges as possible from 0 to numEdges. |
|[computeAdjacency](class_mesh.html#a8b7b39f416aee6d204de79cb65226d05) | Fills buffers with information about the mesh's topology |
|[computeFaceNormals](class_mesh.html#ad2d3073f94942602441016a2ae5c7191) | Calculates normals for each face |
|[computeNormals](class_mesh.html#a80fe9c1e1a35dc5aa5cd088dbe0d08d6) | vertexNormalArray and faceNormalArray filled with appropriate normal values |
|[toArticulatedModel](class_mesh.html#aa25e2fa35851d7660871190eaeab737b) | Returns an articulated model of the mesh |
|[toObj](class_mesh.html#aa6aa873a3f810e2c0bfdb9e08aaf3908) | Writes an object file of the mesh |
|[create](class_mesh.html#acf65d30a393e0e492fa08878472b4847) | Returns a shared pointer to a mesh |
|[isCollapsable](class_mesh.html#a927969b67bb759490deab1acd701354f) | Called by collapseEdges(). Checks if an edge can be safely collapsed. True if not a boundary edge, if collapsing it preserves the manifold and doesn't flip adjacent face normals. |

|[NoiseGen](class_noise_gen.html): | |
|------------|---|
|[generateMountainImage](class_noise_gen.html#abe0d06b9a698ff77c84a5303ba6e4043) | Generates noise bump map for mountains |
|[generateLandImage](class_noise_gen.html#a14748234d3591d3a0afcf0988357ecdc) | Generates noise bump map for land |
|[generateSeaImage](class_noise_gen.html#a20abb147de7b00dc7d7f9c7683e09a4e) | Generates noise bump map for ocean |
|[colorMountainImage](class_noise_gen.html#abe0d06b9a698ff77c84a5303ba6e4043) | Generates an image that can be used to color mountains based on hieght|
|[landMapImage](class_noise_gen.html#ae8024bfc5872a8fc3adff69c30ba009f) | Generates an image that is only the land plane |

|[Planet](class_planet.html): | |
|------------|---|
|[applyNoiseLand](class_planet.html#acef025087d323d0d14c68ed8e808f784) | Generates and maps noise for land |
|[applyNoiseMountain](class_planet.html#a61f483ef01185744916f3d5c880a6737) | Generates and maps noise for mountains |
|[applyNoiseWater](class_planet.html#aae1f673f08375154a869ca9df9547718) | Generates and maps noise for ocean |
|[writeSphere](class_planet.html#a4e6161f7106c7800e162213210cc23bb) | Constructs a sphere of a given recursion depth |
|[getMiddle](class_planet.html#a9264b1a5ed9484f6de3a802b674ccd3e) | Finds the middle between two points |
|[makeIcohedron](class_planet.html#a73f0047f85c0d7138283e9006cc5b729) | Makes an icohedron |
|[subdivideIcoHedron](class_planet.html#a8da7fb007fbfb344c150382ab774629a) | Divides the faces of the icohedron |

|[SolarSystem](class_solar_system.html): | |
|------------|---|
|[initializeEntityTable](class_solar_system.html#adb86a73d324a1cfe13a6abc87d1b841e) | Sets up and writes the entity portion of the scene |
|[initializeModelsTable](class_solar_system.html#af18477b46f91a08f1774fe7ee5ea634e) | Sets up and writes the models portion of the scene |
|[initializeSceneTable](class_solar_system.html#a0edb5083b2b969742aae96984fa0ae00) | Sets up and writes the scene's lightning environment |
|[makeSceneTable](class_solar_system.html#a46cc6fe215f824fe6e3d7e764b7360c2) | Adds entities and models initialized by their own methods to the scene |
|[printSolarSystemToScene](class_solar_system.html#a4f7850f6a605f9fca766c09b0944b94a) | Outputs the Solar system to a scene file |
|[addPlanet](class_solar_system.html#a802f69a37f00a29be495abf30157bd1c) | Adds planet to scene |
|[containsPlanet](class_solar_system.html#ad84bb105d55748dbd2d4216b6ae8e6e1) | Returns true if input planet is in the solar system |
|[removePlanet](class_solar_system.html#a3a190f11cba5adda14c0a21d5898583e) | Removes planet from scene |
|[onInit](class_solar_system.html#a72e98827175f7e21af527c09876b2a06) | Initializes member variables and invokes initialize methods |


Justification
------------------------------------------------------------------------------------------------------------------------------

[Planet](class_planet.html) is responsible for building the actual layout of the planet and uses our Mesh class to create its 3D mesh. We build our own sphere from an icohedron so we can make it as low or high poly as we desire.Our planet class is used for creating spherical heightfield using noise, which are then modified and outputted from inside our mesh class. Our planet heightfield is built by applying noise to a sphere. 

[NoiseGen](class_noise_gen.html) generates noise bump maps for the mountain, land and ocean planet heightfields through separate methods.

[Mesh](class_mesh.html) defines methods to compute adjacency and normal information of the input Mesh, and methods to edit the Mesh. It is used by Planet, which passes in the vertex array and the tri array of faces of the original heightfields into Mesh. Planet then invokes the methods defined in Mesh to collapse mesh edges, to bevel the mesh, and to output it to [G3D::ArticulatedModel](http://g3d.cs.williams.edu/g3d/G3D10/build/manual/class_g3_d_1_1_articulated_model.html) or to OBJ files to be used in our scenes. Collapsing edges simplifies the mesh and makes the faces look less uniform which makes the low polyness more interesting. Bevelling smoothes the edges between faces and gives more of a polygon effect to the mesh. This design choice abstracts mesh editting from mesh creation and allowed us to to work on introducing low polyness separately from generating nice planets.
    
[SolarSystem](class_solar_system.html) abstracts generating the Scene.Any file that includes our planet meshes. It defines separate methods to set up the lighting environment, write entities, write models, add and remove planet meshes from the scene. Defining this class was fundamental in cleaning up our code, since before SolarSystem we generated our whole Scene.Any in App. This abstraction allowed us to more easily and intuitively add features and polish our results. 

Correctness Results
=====================================================================================

Procedural Sphere generation
---------------------------------------------------------------------------------------


![Icosahedron 1 recursion level](2016-12-07_051_starter_r2819_g3d_r981__1_recursion_level.jpg width=200px) ![Icosahedron 8 recursion levels](2016-12-07_052_starter_r2819_g3d_r981__8_recursion_levels.jpg width=200px) ![Icosahedron 8 recursion levels wireframe close-up](2016-12-07_053_starter_r2819_g3d_r981__8_recursion_levels_wireframe_close-up.jpg width=200px) 

Edge Collapsing
---------------------------------------------------------------------------------------
![Mountain - before collapsing wireframe](2016-12-07_037_starter_r2803_g3d_r981__Mountain_-_before_collapsing_wireframe.jpg width=200px) ![Land - before collapsing wireframe](2016-12-07_036_starter_r2803_g3d_r981__Land_-_before_collapsing_wireframe.jpg width=200px)

![Mountain - wireframe after 2200 edges collapsed](2016-12-07_034_starter_r2803_g3d_r981__Mountain_-_wireframe_after_collapsing.jpg width=200px) ![Land - wireframe after 8600 edges collapsed](2016-12-07_032_starter_r2803_g3d_r981__Land_-_wireframe_after_collapsing.jpg width=200px)


Bevelling
---------------------------------------------------------------------------------------
![Mountains - wireframe before](2016-12-07_046_starter_r2803_g3d_r981__Mountains_-_before.jpg width = 200px) ![Land - wireframe before](2016-12-07_045_starter_r2803_g3d_r981__Land_-_wireframe_before.jpg width = 200px) ![Ocean - wireframe before](2016-12-07_044_starter_r2803_g3d_r981__Ocean_-_wireframe_before.jpg width = 200px)


![Mountain - wireframe after](2016-12-07_042_starter_r2803_g3d_r981__Mountain_-_wireframe_after.jpg width = 200px) ![Land - wireframe after](2016-12-07_041_starter_r2803_g3d_r981__Land_-_wireframe_after.jpg width = 200px) ![Ocean wireframe after](2016-12-07_039_starter_r2803_g3d_r981__Ocean_wireframe_after.jpg width = 200px)


Put together into planet
---------------------------------------------------------------------------------------
![Land collapsed and bevelled](2016-12-07_047_starter_r2803_g3d_r981__Land_collapsed_and_bevelled.jpg width = 300px) ![Mountain collapsed and bevelled](2016-12-07_048_starter_r2803_g3d_r981__Mountain_collapsed_and_bevelled.jpg width = 300px)

![Planet put together](2016-12-07_049_starter_r2803_g3d_r981__Planet_put_together.jpg width = 300px) ![Planet 360](2016-12-07_050_starter_r2803_g3d_r981__Planet_360.mp4 width = 300px)

        ![Land - recursion depth 3](landDepth3.jpg width=200px) ![Land - recursion depth 5](landDepth5.jpg width=200px) ![Land - recursion depth 7](landDepth7.jpg width=200px)
        ![Mountain - recursion depth 3](mountainDepth3.jpg width=200px) ![Mountain - recursion depth 5](mountainDepth5.jpg width=200px) ![Mountain - recursion depth 7](mountainDepth7.jpg width=200px)
        ![Planet - recursion depth 3](depth3.jpg width=200px) ![Planet - recursion depth 5](depth5.jpg width=200px) ![Planet - recursion depth 3](depth7.jpg width=200px)


Quality Results
=====================================================================================

We created different planets: 

![Planet1](2016-12-07_006_starter_r2797_g3d_r981__P1_after_collapsing.jpg)

![Planet2](2016-12-07_012_starter_r2797_g3d_r981__P2_after_collapsing.jpg)

![Planet3](2016-12-07_016_starter_r2797_g3d_r981__P3_after_collapsing.jpg)

![Planet4](2016-12-07_025_starter_r2803_g3d_r981__P5_after_collapsing.jpg)

![Planet5](2016-12-07_029_starter_r2803_g3d_r981__P6_after_collapsing.jpg)

![Barbie's Ice Planet Edge collapsed](2016-12-07_054_starter_r2825_g3d_r981__barbie_ice_planet_edge_collapsed.jpg)

![Danger Zone](2016-12-07_059_starter_r2827_g3d_r981__Danger_Zone.jpg)

![Dry Land](2016-12-07_058_starter_r2827_g3d_r981__Dry_Land.jpg)

![](low-poly.jpg)
![](quality2.jpg)
![](1.jpg)


Evocative Results
=====================================================================================
Here, we demonstrate how our planets could be used to create with various models to create interesting scenes and beautiful images. 

![Sparrow's flight](evocative.jpg)

![](video.mp4)

![](qualityTex.jpg)
![](qualityTex2.jpg)
![](lava.jpg)
![](lava2.jpg)

Schedule
===================================================================

|To Do| Date | Person|
|-----|------|-------|
|Sphere Creation Draft| 13 Nov. 2016 | John and Jose|
|Mesh Class Draft| 13 Nov. 2016 | Julia and Matheus|
|Report Draft | 14 Nov. 2016 | John and Jose|
|Sphere Creation MVP| 17 Nov. 2016 | John and Jose|
|Mesh Class MVP| 17 Nov. 2016 | Julia and Matheus|
|Report MVP | 1 Dec. 2016 | All|
|Sphere Creation Polish| 7 Dec. 2016 | John and Jose|
|Mesh Class Polish| 7 Dec. 2016 | Julia and Matheus|
|Report Polish | 7 Dec. 2016 | All|

Change Log
===================================================================
1. Created initial plans. All 11/10/16.
2. Created a seperate mesh class. Julia and Matheus 11/12/16.
3. Created a sperate class for our sphere generator. John and Jose 11/13/16.
4. Sphere generator renamed to Planet. John and Jose 11/14/16
5. Created a noise class to create images with noise. Jose 11/16/16
6. Added GUI to APP. Julia 11/17/16
7. Moved noise class functions to planet class. Not using NoiseGen anymore. John 11/18/16
8. Added solar system class to control Scene file. Jose 12/4

Acknowledgements and Bibliography
============================================

<b>Icosphere Information:</b>

[#Larsen]: Larsen, Ken.  "Subdivision of Icosahedrons". CoreDumping, 15 April 2012. Web. 13, Nov. 2016. http://blog.coredumping.com/subdivision-of-icosahedrons/

<b>Edge Collapsing:</b>

[#Shertler]: [Shertler, Nico](http://stackoverflow.com/users/1210053/nico-schertler) Answer to forum "Mesh Simplification: Edge Collapse Conditions" created by [jaykumarark](http://stackoverflow.com/users/500318/jaykumarark). Stack Overflow, 20 November 2014. Web 27, Nov. 2016. http://stackoverflow.com/questions/27049163/mesh-simplification-edge-collapse-conditions

[#Stanford_Graphics]: "Simplification". Stanford Graphics - CS486, Fall 2010. Web. 14, Nov. 2016. http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/08_Simplification.pdf

<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>

<script src="../common.js"></script>