<meta charset="utf-8"><!-- -*- markdown -*- -->     
   
        **Procedurally Generated, Low-Poly Planet**
        **John Freeman (jcf1@williams.edu), Jose Rivas (jdr3@williams.edu),** 
        **Julia Goldman (jdg2@williams.edu),**
        **and Matheus de Carvalho Souza (mc13@williams.edu)** 

![A unique low-poly planet.](teaser.png border=1)

Introduction
============================================================================================

Despite their lack of realism, low-poly planets, such as the one above, have the ability to be aesthetically beautiful and awe-inspiring. There are a plethora of different styles that these planets can take, but for this project, we endeavored to create a low-poly planet generator that can procedurally generate cartoon-like planets reminiscent of those from Super Mario Galaxy. The cartoon-like feel of these planets allowed us to generate planets that do not have to conform to "real-world" physics, but still have an aesthetically pleasing feel to them.

Specification
============================================================================================

1. Generate a procedurally generated, tesselated planet by implementing the following:
	1. Generate a low-poly planet with the following heightfields:
		1. Sea
		2. Low-Level Terrain
		3. Mountains
	2. Use a noise function to generate these heightfields based on the planet's radius
	3. Use an edge-collapse algorithm to reduce the number of triangles
	4. Bevel the edges of the heightfields' triangles for smoother transitions
	5. Color each position on the heightfields based on constants from a file.  #Ask Ryan about this
	5. Add low-poly objects on the planet:
		1. Small Cars
		2. Fir Trees
		3. Birds
	6. Make the planet rotate on its axis
	7. Make the cars and birds move along predetermined paths 
	8. Use a gradient background for better aesthetic.

2. Provide the capability to change the planet's following paramenters:
	1. Water heightfield's minimum and maximum height
	2. Love-level terrain heightfield's maximum height
	3. Mountain heightfield's maximum height
	4. The planet's theme:
		1. Water Planet
		2. Ice Planet
		3. Mountaineous Planet
		4. Desert Planet
		5. City Planet
		
3. Save the following images to prove correctness:
    1. Change the color of each triangle as follows:
		1. World-space surface normals of the triangle visualized as colors by $\vec{c} = (\n + 1) / 2$ 
		2. World-space hit positions of the triangle visualized as colors by $\vec{c} = P$
	2. Show a low-poly terrain mesh using a simple noise algorithm to bump the vertices.
    3. Show a planet with only one terrain
	4. Show one example of a planet with various terrains

4. Quality Results:
	1. A scene of a planet with some models and an interesting background
	2. A scene of a planet with a moon rotating around it
	3. A unique scene emphasizing our planets' beauty
  
5. Stretch Goals
	1. Add detailed buildings to the planets
	2. Have one planet revolve around another like a moon
  
Topic Overview
=====================================================================================

Heightfields
-----------------------------------------------------------
The planets are represented through a combination of layered, spherical heightfields. From top to bottom, these spheres represent the mountains, land, and water planes of our planet. Each has a unique noise algorithm, which creates the variation in their heights. 

Noise
-----------------------------------------------------------
Perling noise is used to generate the heights at varying locations of our three heightfields. Each field has its own unique noise functions, which rely on each other, in order to make sure the three do not interfere with one another.


Meshes
----------------------------------------------------------
The heightfields are stored as meshes. The low-polyness of the planet comes from the heightfield's mesh structure. A decimation algorithm is used to simplify the mesh. Then Beveling adds rectangles between mesh triangles to smooth out corners.

Decimation Algorithms
----------------------------------------------------------
Decimation algorithms are used, among other things, to simplify meshes by reducing the number of faces while still keeping its underlying shape and topology. 

The decimation algorithm we chose is edge collapsing, which consists of taking the $n$ least important edges away from the mesh, which takes away its adjacent faces. For our purposes we chose the least important edge to be the edge whose anlge between its adjacent face normals is closest to 180 degrees, weighted by the edge length.

Bevelling
-----------------------------------------------------------
In order to create a smooth transition between triangles, we used a bevelling function. This functions shrinks each triangle face by a specified amount, causing each face to become disconnected from one another. It then fills in the missing spaces with rectangles, reconnecting the triangles together. 

![A planet with shrunken faces](beveling1.jpg width=300px)![A beveled surface](beveling.jpg width=300px)![Close-up shot](bevelingclose.jpg width=300px)

The result is a more cartoon-like feel for the planet, because it gets rid of extremely sharp edges.

Design
=====================================================================================

The following is a description of our design.

Flowchart
-------------------------------------------------------------------------------------
GAPP::makePlanetGUI() -> Generate Button -> 

Class Descriptions
-----------------------------------------------------------------------------------------------------------------------------

|[Planet](class_planet.html): | |
|------------|---|
|[applyNoiseLand](class_planet.html#acef025087d323d0d14c68ed8e808f784) | Generates and maps noise for land |
|[applyNoiseMountain](class_planet.html#a61f483ef01185744916f3d5c880a6737) | Generates and maps noise for mountains |
|[applyNoiseWater](class_planet.html#aae1f673f08375154a869ca9df9547718) | Generates and maps noise for ocean |
|[writeSphere](class_planet.html#a4e6161f7106c7800e162213210cc23bb) | Constructs a sphere of a given recursion depth |
|[getMiddle](class_planet.html#a9264b1a5ed9484f6de3a802b674ccd3e) | Finds the middle between two points |
|[makeIcohedron](class_planet.html#a73f0047f85c0d7138283e9006cc5b729) | Makes an icohedron |
|[subdivideIcoHedron](class_planet.html#a8da7fb007fbfb344c150382ab774629a) | Divides the faces of the icohedron |

|[Mesh](class_mesh.html): | |
|------------|---|
|[bevelEdges](class_mesh.html#adc7558052d2c7fb4ee0697805ef7cd72) | Creates new vertex and index arrays in which the original triangles are separated and shrunk andvthe gaps between them are filled in with more triangles |
|[collapseEdges](class_mesh.html#a015dfb6334430099b0061bbdc24a7289) | As outlined by Stanford Graphics http://graphics.stanford.edu/courses/cs468-10-fall/LectureSlides/08_Simplification.pdf Calls isCollapsable(). Collapses the numEdges most unimportant edges. |
|[computeAgency](class_mesh.html#a8b7b39f416aee6d204de79cb65226d05) | Fills buffers with information about the mesh's topology |
|[computeFaceNormals](class_mesh.html#ad2d3073f94942602441016a2ae5c7191) | Calculates normals for each face |
|[computeNormals](class_mesh.html#a80fe9c1e1a35dc5aa5cd088dbe0d08d6) | vertexNormalArray and faceNormalArray filled with appropriate normal values |
|[toArticulatedModel](class_mesh.html#aa25e2fa35851d7660871190eaeab737b) | Returns an articulated model of the mesh |
|[toObj](class_mesh.html#aa6aa873a3f810e2c0bfdb9e08aaf3908) | Writes an object file of the mesh |
|[create](class_mesh.html#acf65d30a393e0e492fa08878472b4847) | Returns a shared pointer to a mesh |
|[edgeLength](class_mesh.html#ac5a3107caa5fd891de64985be4e653aa) | Returns the length of a given edge |
|[greaterAngle](class_mesh.html#a71bb93a4e76f8c6bc9f2ef7c1d70c80d) | Returns true if the angle between the normal of the adjacent faces of elem1 is greater than that of the adjacent faces of elem2  |
|[isCollapsable](class_mesh.html#a927969b67bb759490deab1acd701354f) | Called by collapseEdges(). Checks if an edge can be safely collapsed. True if not a boundary edge, if collapsing it doesn't create a manifold and doesn't flip adjacent face normals. |

|[Angled Vertex](class_angled_vertex.html): | |
|------------|---|
|[operator<](class_angled_vertex.html#af8dea9a741ccba035b79f5015adc7572) | Used for sorting vertices by angle |
|[operator>](class_angled_vertex.html#ae6d68c335a0bf593ac5b9d9e85c1407a) | Used for sorting vertices by angle |

|[App](class_app.html): | |
|------------|---|
|[addPlanetToScene](class_app.html#aa16db878375c7fa7a16108e7b9edb898) | Adds an articulated model of a mesh to the current scene |
|[makePlanetGUI](class_app.html#a9bc72b237ac25e5c1e793c9104221320) | Provides the ability to generate a planet on command |

Justification
------------------------------------------------------------------------------------------------------------------------------

Our planet class is used for creating spherical heightfield using noise, which are then modified and outputted from inside our mesh class. Our planet heightfield is built by applying noise to a sphere. We build our own sphere from an icohedron so we can make it as low or high poly as we desire.

Planet is responsible for building the actual layout of the planet and uses our Mesh class to create its 3D mesh.

Mesh is responsible for building and editting the planet's mesh.

Results
=====================================================================================

Correctness Results
---------------------------------------------------------------------------------------

![](noise.png)
![](a.jpg)
![](low-poly.jpg)

![](landDepth3.jpg width=200px) ![](landDepth5.jpg width=200px) ![](landDepth7.jpg width=200px)
![](mountainDepth3.jpg width=200px) ![](mountainDepth5.jpg width=200px) ![](mountainDepth7.jpg width=200px)
![](depth3.jpg width=200px) ![](depth5.jpg width=200px) ![](depth7.jpg width=200px)


Quality Results
--------------------------------------------------------------------------------------
Here, we show high quality images that show both the advantages and limitations of our project.  

![](low-poly.jpg)

![](mountainous_planet.jpg)

![](https://www.youtube.com/watch?v=RyYEoQET4ZY) 

Evocative Results
-------------------------------------------------------------------------------------
Here, we demonstrate how our planets could be used to create with various models to create interesting scenes and beautiful images. 

![.](moon.jpg)

![.](low-poly_planet.jpg)


Schedule
===================================================================

|To Do| Date | Person|
|-----|------|-------|
|Sphere Creation Draft| 13 Nov. 2016 | John and Jose|
|Mesh Class Draft| 13 Nov. 2016 | Julia and Matheus|
|Report Draft | 14 Nov. 2016 | John and Jose|
|Sphere Creation MVP| 17 Nov. 2016 | John and Jose|
|Mesh Class MVP| 17 Nov. 2016 | Julia and Matheus|
|Report MVP | 1 Dec. 2016 | All|
|Sphere Creation Polish| 7 Dec. 2016 | John and Jose|
|Mesh Class Polish| 7 Dec. 2016 | Julia and Matheus|
|Report Polish | 7 Dec. 2016 | All|

Change Log
===================================================================
1. Created initial plans. All 11/10/16.
2. Created a seperate mesh class. Julia and Matheus 11/12/16.
3. Created a sperate class for our sphere generator. John and Jose 11/13/16.
4. Sphere generator renamed to Planet. John and Jose 11/14/16
5. Created a noise class to create images with noise. Jose 11/16/16
6. Added GUI to APP. Julia 11/17/16
7. Moved noise class functions to planet class. Not using NoiseGen anymore. John 11/18/16

Acknowledgements and Bibliography
============================================

<b>Icosphere Information:</b>

[#Larsen]: Larsen, Ken.  "Subdivision of Icosahedrons". CoreDumping, 15 April 2012. Web. 13, Nov. 2016. http://blog.coredumping.com/subdivision-of-icosahedrons/

<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>

<script src="../common.js"></script>